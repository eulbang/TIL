# JaveScript
### History of JavaScript
#### ECMAScript
- Ecma International이 정의하고 있는 표준화된 스크립트 프로그래밍 언어 명세
  - 스크립트 언어가 준수해야 하는 규칙, 세부사항 등을 제공
- JavaScript는 ECMAScript 표준을 구현한 구체적인 프로그래밍 언어
- ECMAScript의 명세를 기반으로 하여 웹 브라우저나 Node.js와 같은 환경에서 실행됨
  - ECMAScript는 JavaScript의 표준이며, JavaScript는 ECMAScript 표준을 따르는 구체적인 프로그래밍 언어
  - ECMAScript는 언어의 핵심을 정의하고, JavaScript는 ECMAScript 표준을 따라 구현된 언어로 사용됨
#### ECMAScript의 역사
- ECMAScript 5(ES5)에서 안정성과 생산성을 크게 높임(2009)
- ECMAScript 2015(ES6)에서 객체지향 프로그래밍 언어로써 많은 발전을 이루어, 역사상 가장 중요한 버전으로 평가됨(2015)
### 변수
- 식별자(변수명) 작성 규칙
  - 반드시 문자, 달러('$') 또는 밑줄('_')로 시작
  - 대소문자를 구분
  - 예약어 사용 불가
- 식별자(변수명) Naming case
  - 카멜 케이스(camelCase)
    - 변수, 객체, 함수에 사용
  - 파스칼 케이스(PascalCase)
    - 클래스, 생성자에 사용
  - 대문자 스네이크 케이스(SNAKE_CASE)
    - 상수에 사용
- 변수 선언 키워드 3가지
  1. let
    - 블록 스코프(block scope)를 갖는 지역 변수를 선언
    - 재할당 가능
    - 재선언 불가능
    - ES6에서 추가
  2. const
    - 블록 스코프(block scope)를 갖는 지역 변수를 선언
    - 재할당 불가능 (선언 시 반드시 초기값 설정 필요)
    - 재선언 불가능
    - ES6에서 추가
  3. var
  - 블록 스코프 (block scope)
    - if, for, 함수 등의 **'중괄호({}) 내부'**를 가리킴
    - 블록 스코프를 가지는 변수는 블록 바깥에서 접근 불가능
  - 기본적으로 const 사용을 권장
  - 재할당이 필요하다면 그때 let으로 변경해서 사용
### 데이터 타입
- 원시 자료형 : 변수에 값이 직접 저장되는 자료형(불변, 값이 복사)
  - Number
    - 정수 또는 실수형 숫자를 표현하는 자료형
  - String
    - 텍스트 데이터를 표현하는 자료형
    - '+' 연산자를 사용해 문자열끼리 결합
    - 뺄셈, 곱셈, 나눗셈 불가능
    - Template Literals (템플릿 리터럴)
      - 내장된 표현식을 허용하는 문자열 작성 방식
      - Backtick('')을 이용하며, 여러 줄에 걸쳐 문자열을 정의할 수도 있고 JavaScript의 변수를 문자열 안에 바로 연결할 수 있음
      - 표현식은 '$'와 중괄호(${expression})로 표기
  - Boolean
  - null : 값이 없음
    - null 의 타입이 object 로 출력 - 버그
  - undefined : 할당조차 안됐음
- 참조 자료형 : 객체의 주소가 저장되는 자료형(가변, 주소가 복사)
  - Objects(Object, Array, Function)
### 연산자
- 할당 연산자
- 증감 연산자
- 비교 연산자
- 동등 연산자
  - '암묵적 타입 변환' 통해 타입을 일치시킨 후 같은 값인지 비교
- 일치 연산자 (===) : 주로 사용
- 논리 연산자
### 제어문
#### 조건문
- if
  - else if
  - else
- 삼항 연산자
  - condition ? expression1 : expression2
#### 반복문
- while
- for
- for...in
  - 객체의 열거 가능한 속성에 대해 반복
  - 키 반복
- for...of
  - 반복 가능한 객체(배열, 문자열 등)에 대해 반복
  - 값 반복
## DOM
- document 객체
- 웹 페이지(Document)를 구조화된 객체로 제공하여 프로그래밍 언어가 페이지 구조에 접근할 수 있는 방법을 제공
  - 문서 구조, 스타일, 내용 등을 변경할 수 있도록 함
- DOM API
  - 다른 프로그래밍 언어가 웹 페이지에 접근 및 조작 할 수 있도록 페이지 요소들을 객체 형태로 제공하며 이에 따른 메서드 또한 제공
- DOM 특징
  - DOM에서 모든 요소, 속성, 텍스트는 하나의 객체
  - 모두 document 객체의 하위 객체로 구성됨
- DOM tree
  - 브라우저는 HTML 문서를 해석하여 DOM tree라는 객체 트리로 구조화
    - 객체 간 상속 구조가 존재
### DOM 선택
- 선택 메서드
- document.querySelector()
  - 요소 한 개 선택
  - 제공한 CSS selector를 만족하는 첫 번째 element를 선택
- document.querySelectorAll()
  - 요소 여러 개 선택
  - 제공한 CSS selector를 만족하는 NodeList를 반환
### DOM 조작
- 속성 조작
  - 클래스 속성 조작
  - 'classList' property : 요소의 클래스 목록을 DOMTokenList(유사 배열) 형태로 반환
    - element.classList.add()
      - 지정한 클래스 값을 추가
    - element.classList.remove()
      - 지정한 클래스 값을 제거
    - element.classList.toglle()
      - 클래스가 존재한다면 제거하고 false를 반환
      - 클래스가 존재하지 않으면 추가하고 true를 반환
  - 일반 속성 조작
    - Element.getAttribute()
      - 해당 요소에 지정된 값을 반환 (조회)
    - Element.setAttribute(name, value)
      - 지정된 요소의 속성 값을 설정
      - 속성이 이미 있으면 기존 값을 갱신
        - 그렇지 않으면 지정된 이름과 값으로 새 속성이 추가
    - Element.removeAttribute()
      - 요소에서 지정된 이름을 가진 속성 제거
- HTML 콘텐츠 조작
- DOM 요소 조작
  - document.createElement(tagName)
    - 작성한 tagName의 HTML요소를 생성하여 반환
  - Node.appenChild()
    - 한 Node를 특정 부모 Node의 자식 NodeList 중 마지막 자식으로 삽입
    - 추가된 Node 객체를 반환
  - Node.removeChile()
    - DOM에서 자식 Node를 제거
    - 제거된 Node를 반환
- style 조작
### 함수
- Function : 참조 자료형에 속하며 모든 함수는 Function object
- 함수 정의
  - function name ([param],..) {return value}
  - return 값이 없다면 undefined를 반환
  - 선언식/표현식
  - 함수 표현식 특징
    - 함수 이름이 없는 '익명 함수'를 사용할 수 있음
    - 선언식과 달리 표현식으로 정의한 함수는 **호이스팅** 되지 않으므로 함수를 정의하기 전에 먼저 사용할 수 없음
- 매개변수
  1. 기본 함수 매개변수
  2. 나머지 매개변수
    - 임의의 수의 인자를 '배열'로 허용하여 가변 인자를 나타내는 방법
  - 매개변수 > 인자
    - 누락된 인자는 undefined로 할당
  - 매개변수 < 인자
    - 초과 입력된 인자는 사용하지 않음
- Spread syntax : '...' : 전개 구문
  - 전개 구문 활용처
    1. 함수와의 사용
      - 함수 호출 시 인자 확장
      - 나머지 매개변수(압축)
    2. 객체와의 사용
    3. 배열과의 사용
- 화살표 함수 : 함수 표현식의 간결한 표현법
  - function 키워드 제거 후 매개변수와 중괄호 사이에 화살표(=>) 작성
  - const arrow = name => 'hello, ${name}'
  - **object를 다룰 때 신경 쓸 부분이 줄어든다**
#### 세미콜론 (semicolon)
- 자바스크립트는 문장 마지막 세미콜론(';')을 선택적으로 사용 가능
- 세미콜론이 없으면 ASI에 의해 자동으로 세미콜론이 삽입됨
- JavaScript를 만든 Brendam Eich 또한 세미콜론 작성을 반대
### 이벤트
- 무언가 일어났다는 신호, 사건
- 웹에서의 모든 동작은 이벤트 발생과 함께 한다.
- 'event' object
  - DOM 에서 이벤트가 발생했을 때 생성되는 객체
  - mouse, input, keyboard, touch ...
- .addEventListener()
  - 특정 이벤트를 DOM 요소가 수신할 때마다 콜백 함수를 호출
  - EventTarget.addEventListener(type, handler)
    - type
      - 수신할 이벤트 이름
      - 문자열로 작성
    - handler
      - 발생한 이벤트 객체를 수신하는 콜백 함수
      - 콜백 함수는 발생한 event object를 유일한 매개변수로 받음
- event handler
  - 이벤트가 발생했을 때 발생하는 함수
  - 사용자의 행동에 어떻게 반응할지를 JavaScript 코드로 표현한 것
- 버블링
  - 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러 뿐만 아니라 부모 요소의 핸들러가 동작하는 현상
  - 반대 : 캡처링
### enevt handler 활용
### 이벤트 기본 동작 취소
- HTML의 요소가 기본적으로 가지고 있는 이벤트가 때로는 방해가 되어 기본 동작을 취소할 필요가 있음
- .preventDefault() : 해당 이벤트에 대한 기본 동작을 실행하지 않도록 지정

-----

### 객체
- Object : 키로 구분된 데이터 집합을 저장하는 자료형 (data collection)
#### 구조 및 속성
  - 중괄호('{}')를 이용해 작성
  - 중괄호 안에는 key:value 쌍으로 구성된 속성(property)를 여러 개 작성 가능
  - key는 문자형만 허용
  - value는 모든 자료형 허용
- 속성 참조
  - 점 또는 대괄호로 객체 요소 접근
  - key 이름에 띄어쓰기 같은 구분자가 있다면 대괄호 접근만 가능
- 'in' 연산자
  - 속성이 객체에 존재하는지 여부를 확인
#### 객체와 함수
- Method
  - 객체 속성에 정의된 함수
  - object.method() 방식으로 호출
  - 메서드는 객체를 '행동'할 수 있게 함
#### this
- Method : 객체 속성에 정의된 함수
  - 'this' 키워드를 사용해 객체에 대한 특정한 작업을 수행 할 수 있음
- 'this' keyword : 함수나 메서드를 호출한 객체를 가리키는 키워드
  - 함수 내에서 객체의 속성 및 메서드에 접근하기 위해 사용
  - **호출하는 방법**에 따라 가리키는 대상이 다름
    - 단순 호출 : 전역 객체
    - 메서드 호출 : 메서드를 호출한 객체
- **화살표 함수는 자신만의 this를 가지지 않기 때문에** 외부 함수에서의 this 값을 가져옴
  - 화살표 함수의 역할 => this가 외부 함수를 가져오도록 변경
- this가 미리 정해지지 않고 호출 방식에 의해 결정되는 것은
  - 장점 : 함수(메서드)를 하나만 만들어 여러 객체에서 재사용할 수 있다
  - 단점 : 실수로 이어질 수 있다
#### 추가 객체 문법
1. 단축 속성
  - 키 이름과 값으로 쓰이는 변수의 이름이 같은 경우 단축 구문을 사용할 수 있음
2. 단축 메서드
  - 메서드 선언 시 function 키워드 생략 가능
3. 계산된 속성
  - 키가 대괄호로 둘러싸여 있는 속성
  - 고정된 값이 아닌 변수 값을 사용할 수 있음
4. 구조 분해 할당
  - 배열 또는 객체를 분해하여 객체 속성을 변수에 쉽게 할당할 수 있는 문법
5. Object with '전개 구문'
  - 객체 복사
    - 객체 내부에서 객체 전개
  - 얕은 복사에 활용 가능
6. 유용한 객체 메서드
  - Object.keys()
  - Object.values()
7. Oprional chaining ('?.')
  - 속성이 없는 중첩 객체를 에러 없이 접근할 수 있는 방법
  - 만약 참조 대상이 null 또는 undefined라면 에러가 발생하는 것 대신 평가를 멈추고 undefined를 반환
  - 만약 Optional chaining을 사용하지 않는다면 '&&' 연산자를 사용해야 함
  - **남용 금지**
- JSON
  - JavaScript Object Notation
  - Key-Value 형태
  - 오브젝트와 유사한 구조를 가지고 있지만 형식이 있는 **문자열**
### 배열
- Object
  - 키로 구분된 데이터 집합을 저장하는 자료형 -> 순서 보장 X
  - 순서가 있는 collection이 필요
- Array
  - 순서가 있는 데이터 집합을 저장하는 자료구조
  - 대괄호('[]')를 이용해 작성
  - 요소 자료형 : 제약 없음
  - length 속성을 사용해 배열에 담긴 요소가 몇 개인지 알 수 있음
#### 배열 메서드
- push / pop : 배열 끝 요소를 추가 / 제거
- unshift / shift : 배열 앞 요소를 추가 / 제거
#### Arrayhelper method
- 배열 조작을 보다 쉽게 수행할 수 있도록 하는 특별한 메서드 모음
- 배열의 각 요소를 순회하며 각 요소에 대해 함수(콜백함수)를 호출
- **forEach**
  - 배열 내의 모든 요소 각각에 대해 함수(콜백함수)를 호출
  - 반환 값 없음
  - arr.forEach(callback(item[, index[, array]]))
    - item : 처리할 배열의 요소
    - index : 처리할 배열 요소의 인덱스 (선택 인자)
    - array : forEach를 호출한 배열 (선택 인자)
  - **간결하고 가독성이 높음**
  - **break, continue 사용 불가**
- map
  - 배열 내의 모든 요소 각각에 대해 함수(콜백함수)를 호출
  - 함수 호출 결과를 모아 새로운 배열을 반환
  - arr.map(callback(item[, index[, array]]))
    - forEach의 매개 변수와 동일
    - 배열의 각 요소에 대해 실행한 "callback의 결과를 모은 새로운 배열"
- filter
  - 콜백 함수의 반환 값이 참인 요소들만 모아서 새로운 배열을 반환
- find
  - 콜백 함수의 반환 값이 참이면 해당 요소를 반환
- some
  - 배열의 요소 중 적어도 하나라도 콜백 함수를 통과하면 true를 반환하며 즉시 배열 순회 중지
  - 모두 통과하지 못하면 false를 반환
- every
  - 배열의 모든 요소가 콜백 함수를 통과하면 true를 반환
  - 하나라도 통과하지 못하면 즉시 false를 반환하고 배열 순회 중지
- **배열은 객체다**
  - 배열도 키와 속성들을 담고 있는 참조 타입의 객체
  - 배열의 요소를 대괄호 접근법을 사용해 접근하는 건 객체 문법과 같음
    - 배열의 키는 숫자
  - 숫자형 키를 사용함으로써 배열은 객체 기본 기능 이외에도 "순서가 있는 컬렉션"을 제어하게 해주는 특별한 메서드를 제공하는 것
#### 추가 배열 문법
### 비동기
- Synchronous : 동기
  - 프로그램의 실행 흐름이 순차적으로 진행
  - 하나의 작업이 완료된 후에 다음 작업이 실행되는 방식
- Asysnchronous : 비동기
  - 프로그램의 실행 흐름이 순차적이지 않으며, 작업이 완료되기를 기다리지 않고 다음 작업이 실행되는 방식
  - 작업의 완료 여부를 신경 쓰지 않고 동시에 다른 작업들을 수행할 수 있음
- JavaScript : Single Thread 언어
  - Thread란?
  - 작업을 처리할 때 실제로 작업을 수행하는 주체로, multi-thread라면 업무를 수행할 수 있는 주체가 여러 개라는 의미
  - 비동기 관련 작업은 "브라우저" 또는 "Node"와 같은 환경에서 처리
### AJAX
- XMLHttpRequest 기술을 사용해 복잡하고 동적인 웹 페이지를 구성하는 프로그래밍 방식 (요즘은 XML 대신 JSON)
  - 비동기적인 웹 애플리케이션 개발을 위한 기술
- 전체 페이지가 다시 로드되지 않고 HTML 페이지 일부 DOM 만 업데이트
  - 웹 페이지 일부가 다시 로드되는 동안에도 코드가 계속 실행되어, 비동기식으로 작업 할 수 있음
- XHR
  - 서버와 상호작용할 때 사용하는 객체
  - 브라우저와 서버 간의 네트워크 요청을 전송할 수 있음
  - 사용자의 작업을 방해하지 않고 페이지의 일부를 업데이트할 수 있음
  - 요청의 상태와 응답을 모니터링할 수 있음
- 기존 기술과의 차이 - AJAX
  - 서버 - 클라이언트 간 요청에서 새로운 페이지를 받는 것이 아닌 필요한 부분만 받아 기존 페이지의 일부를 수정 (새로고침 X)
### Callback과 Promise
- 비동기 콜백
  - 비동기 처리의 핵심은 Web API로 들어오는 순서가 아니라 **작업이 완료되는 순서에 따라 처리**한다는 것
  - 개발자 입장에서 **코드의 실행 순서가 불명확**하다는 단점 존재
  - 실행 결과를 예상하면서 코드를 작성할 수 없게 함
  > 콜백 함수를 사용
  - 비동기적으로 처리되는 작업이 완료되었을 때 실행되는 함수
  - 연쇄적으로 발생하는 비동기 작업을 **순차적으로 동작**할 수 있게 함
  > 작업의 순서와 동작을 제어하거나 결과를 처리하는 데 사용
  - 보통 어떤 기능의 실행 결과를 받아서 다른 기능을 수행하기 위해 많이 사용
  - 이 과정을 작성하다 보면 비슷한 패턴이 계속 발생
    - 콜백 지옥 (피라미드) 발생
- Promise
  - JavaScript에서 비동기 작업의 결과를 나타내는 객체
  - 비동기 작업이 완료되었을 때 결과 값을 반환하거나, 실패 시 에러를 처리할 수 있는 기능을 제공
  - 콜백 지옥 문제를 해결하기 위해 등장한 비동기 처리를 위한 객체
  - "작업이 끝나면 실행 시켜 줄게"라는 약속
    - 성공에 대한 약속 then()
    - 실패에 대한 약속 catch()
### Axios
- JavaScript에서 사용되는 HTTP 클라이언트 라이브러리
- 서버와의 HTTP 요청과 응답을 간편하게 처리할 수 있도록 도와주는 도구
- 브라우저를 위한 XHR 객체 생성
- 간편한 API를 제공하며, Promise 기반의 비동기 요청을 처리
> 주로 웹 애플리케이션에서 서버와 통신할 때 사용
- CDN 방식으로 사용하기
  - https://axios-http.com/
- **then** : 성공하면 수행할 로직
- **catch** : 실패하면 수행할 로직
- axios로 처리한 비동기 로직은 항상 promise 객체를 반환
> 계속해서 chaining을 할 수 있음
> then을 계속 이어나가면서 작성할 수 있게 됨
### 정리
- AJAX
  - 하나의 특정한 기술을 의미하는 것이 아니며, 비동기적인 웹 애플리케이션 개발에 사용하는 기술들을 묶어서 지칭
- Axios
  - 클라이언트 및 서버 사이에 HTTP 요청을 만들고 응답을 처리하는데 사용되는 자바스크립트 라이브러리 (Promise API 지원)
> 프론트엔드에서 Axios를 활용해 DRF로 만든 API 서버로 요청을 보내서 데이터를 받아온 후 처리하는 로직을 작성하게 됨
- 차이 비교
  - block/non-block
  - sync/Async