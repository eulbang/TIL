import sys
sys.stdin = open('Sample_input.txt')

# 철수는
# N개의
# 문제가
# 순차적으로
# 주어지는
# 면접에서
# 문제들
# 중
# 정확히
# M개를
# 맞추었다.
#
# 어떤
# 문제들을
# 맞추었는지는
# 기억이
# 안
# 나지만
# 정확히
# M개를
# 맞추었다는
# 것은
# 사실이다.
#
# 이
# 면접에서는
# 연속으로
# 문제를
# 맞추는
# 경우
# 점수를
# 더
# 많이
# 준다.
#
# 점수가
# 계산되는
# 방법은
# 카운터를
# 이용하는
# 것이다.계산되는
# 방법은
# 다음과
# 같다.
#
# 1.
# 카운터의
# 값은
# 처음에
# 0
# 이다.
#
# 2.
# 문제를
# 틀리는
# 경우, 카운터는
# 항상
# 0
# 으로
# 리셋되고
# 해당
# 문제에
# 대해서는
# 0
# 점이
# 부여된다.
#
# 3.
# 문제를
# 맞추는
# 경우, 카운터는
# 1
# 증가되고
# 해당
# 문제에
# 대해서는
# 1
# 점이
# 더해진다.
#
# 4.
# 카운터가
# 주어진
# K가
# 된
# 경우, 해당
# 문제에
# 대해
# 1
# 점이
# 더해지고, 카운터는
# 0
# 으로
# 리셋되면서
# 동시에
# 전체
# 점수가
# 2
# 배가
# 된다.
#
# 철수가
# M개의
# 문제를
# 맞추는
# 모든
# 가능한
# 경우들
# 중
# 받은
# 총점이
# 최소인
# 경우를
# 찾아
# 그
# 점수를
# 제시하라.
#
# 아래
# 입력
# 예의
# 첫
# 번째
# 테스트
# 케이스는, 총
# 8
# 개의
# 문제
# 중
# 7
# 개의
# 문제를
# 맞추고, 연속으로
# 3
# 개의
# 문제를
# 맞출
# 때마다
# 점수가
# 2
# 배가
# 되는
# 조건이다.
#
# 가능한
# 최소
# 점수
# 방법은
# 6
# 번째
# 문제를
# 틀리고
# 나머지
# 문제를
# 다
# 맞추는
# 것이다.
#
# 이
# 경우
# 점수는, 문제가
# 진행되는
# 순서
# 대로, 1
# 점, 2
# 점, 6
# 점, 7
# 점, 8
# 점, 8
# 점, 9
# 점, 10
# 점이다.
#
# 3
# 번째
# 문제를
# 맞추었을
# 때
# 두
# 배로
# 점수가
# 늘면서
# 6
# 점이
# 되었다는
# 것에
# 주의하라.
#
# [제약사항]
#
# 1.
# N은
# 3
# 이상
# 500
# 이하이다.(3 ≤ N ≤ 500)
#
# 2.
# M과
# K는
# 2
# 이상
# N
# 이하의
# 값이다.
#
# 3.
# 풀이가
# 불가능한
# 경우는
# 주어지지
# 않는다.
#
# 4.
# 답은
# 32
# 비트
# int의
# 범위를
# 넘지
# 않음이
# 보장된다.
#
# [입력]
#
# 가장
# 첫
# 줄에는
# 테스트
# 케이스의
# 총
# 수가
# 주어진다.
#
# 그
# 다음
# 줄부터
# 각
# 테스트
# 케이스가
# 주어진다.
#
# 모든
# 테스트
# 케이스들은
# 각각
# 한
# 줄로
# 구성된다.
#
# 각
# 테스트
# 케이스는
# N, M, K의
# 값이
# 공백을
# 사이에
# 두고
# 주어진다.
#
# [출력]
# 출력의
# 각
# 줄은 ‘  # x’로 시작하고, 공백을 한 칸 두고 문제에서 정의된 최소 점수를 출력한다. 단, x는 테스트 케이스의 번호이다.
#
# [입력 예]
#
# 3 // 테스트
# 케이스의
# 수
#
# 8
# 7
# 3 // N = 8, M = 7, K = 3, 테스트
# 케이스  # 1
#
# 3
# 3
# 3 // N = 3, M = 3, K = 3, 테스트
# 케이스  # 2
#
# 5
# 2
# 3 // N = 5, M = 2, K = 3, 테스트
# 케이스  # 3
#
# [출력 예]
#
#
# # 1 10
#
# # 2 6
#
# # 3 2

def dfs(idx, cnt, passed_cnt, result):
    global min_result

    if N > M*2:
        min_result = min(min_result, passed_cnt)
        return

    if idx > N-1 and passed_cnt != 0:
        return

    if idx > N-1 or passed_cnt == 0:
        min_result = min(min_result, result)
        return

    if result > min_result:
        return

    if passed_cnt + idx == N:
        if cnt == K-1:
            dfs(idx+1, 0, passed_cnt-1, (result+1)*2)
        else:
            dfs(idx+1, cnt+1, passed_cnt-1, result+1)
    else:
        if cnt == K-1:
            dfs(idx + 1, 0, passed_cnt - 1, (result+1)*2)
        if cnt < K-1:
            dfs(idx + 1, cnt + 1, passed_cnt - 1, result + 1)
        else:
            dfs(idx+1, 0, passed_cnt, result)

    return

T = int(input())
# T -= 29
for test_case in range(1, T + 1):
    N, M, K = map(int, input().split())

    min_result = 99999

    dfs(0, 0, M, 0)

    print(f'#{test_case} {min_result}')